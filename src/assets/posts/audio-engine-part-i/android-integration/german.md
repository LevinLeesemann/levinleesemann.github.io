Android war auch nicht komplett neues Terrain. Ich hatte bereits eine funktionale, wenn auch nie veröffentlichte, Android-Implementierung für meine Metronom-App gebaut, also wusste ich ungefähr, worauf ich mich einlasse. In der Praxis bedeutete das: Start in Kotlin, dann durch JNI und schließlich in C++, da Oboe dort lebt. Dabei fällt einiges an Glue-Code an, und während nichts davon besonders spannend ist, lässt es sich nur schwer vermeiden.

Wie bei den anderen Plattformen begann ich damit, eine Test-Harness-App zusammen mit einer Bibliothek zu erstellen, die die eigentliche Audio-Treiber-Implementierung enthält. Das Setup-Muster für jede Plattform war zu diesem Zeitpunkt ziemlich klar: Eine Bibliothek mit einem Producer- und einem Consumer-Thread, etwas native Audio-API-Konfiguration, Implementierung der KMP-Interface-Funktionen und eine Test-Harness-App, um das Ganze laufen zu lassen.

Wie man sich vorstellen kann, sah die Android-Implementierung der iOS-Version recht ähnlich. Der Hauptunterschied war das Threading-Modell. Anstatt platformverwaltete Queues zu nutzen, lief der Producer auf einem dedizierten C++-Thread. Die Consumer-Seite wurde durch Obos Callback-Mechanismus abgewickelt, was zu diesem Zeitpunkt ebenfalls vertraut wirkte.

Während sich das alles zusammenfügte, wurde zunehmend klar, dass ich viele der gleichen Logik erneut implementierte, die ich bereits für Web und iOS geschrieben hatte. Das ständige Wechseln zwischen allen drei Plattformen wurde auch knifflig, da jede leicht unterschiedliche Einschränkungen und Erwartungen hatte. So konnte man leicht vergessen, welche Logik wo in einer bestimmten nativen Schicht untergebracht war.

Beim Schreiben des ganzen Glue-Codes wurde ein weiteres Problem immer offensichtlicher. Die Rust-Engine basierte weiterhin auf globalen Statics, und das Aufräumen von Ressourcen war im Design bisher kaum berücksichtigt. Das mag für einen schnellen Prototypen akzeptabel sein, für mobile Plattformen ist es jedoch ein echtes Problem – vor allem, wenn man Re-Initialisierung nach Sleep, Unterbrechungen durch andere Apps, die Audio benötigen, usw. berücksichtigen muss. Dieses Thema, zusammen mit der zuvor erwähnten Logik-Überlappung, trieb die nächste Entwicklungsrunde an.
