Man könnte sich jetzt tief in die Details der [digitalen Audioverarbeitung](https://www.izotope.com/en/learn/digital-audio-basics-sample-rate-and-bit-depth) vertiefen, aber auf hoher Ebene wird Audio typischerweise als eine Folge von Fließkommawerten dargestellt. Jeder Float liegt normalerweise zwischen -1,0 und 1,0 und repräsentiert die Amplitude des Signals zu einem bestimmten Zeitpunkt. Anstatt mit einzelnen Samples zu arbeiten, verarbeiten Audiosysteme diese Werte in Blöcken, sogenannten buffers. Zur Orientierung: Buffers sind oft Potenzen von zwei in der Größe, häufig etwa 256 oder 512 Samples.

Die meisten Echtzeit-Audiosysteme basieren auf einem [Producer-Consumer-Modell](https://jenkov.com/tutorials/java-concurrency/producer-consumer.html). Dabei gibt es in der Regel einen dedizierten Audio-Thread, der als Consumer fungiert. Dieser Thread gehört zum nativen Audiosystem der Plattform und ist dafür verantwortlich, die buffers in sehr präzisen Intervallen abzurufen, oft eng getaktet mit der zugrunde liegenden Audio-Hardware. Der Consumer sieht auf jeder Plattform in diesem Projekt etwas anders aus – zum Beispiel als `AudioWorklet` im Web oder als `AURenderCallback` auf iOS – folgt aber letztlich der gleichen Logik.

Auf der anderen Seite steht der Producer, der dafür zuständig ist, die Audiodaten im Voraus zu erzeugen. Dieser läuft normalerweise auf einem separaten Thread, nicht auf dem Haupt-UI-Thread, und füllt kontinuierlich buffers mit Samples, sodass sie bereitstehen, wenn der Audio-Thread sie abruft.

Producer und Consumer sind meist über einen [Ringpuffer](https://de.wikipedia.org/wiki/Ringpuffer) verbunden. Ein Ringpuffer ist ein zusammenhängender Speicherblock, der zirkulär wiederverwendet wird. Wenn der Producer das Ende des buffers erreicht, springt er zurück zum Anfang. Für Audio funktioniert das gut, wenn der Producer dem Consumer leicht voraus ist, üblicherweise um ein paar buffers. Während der Consumer buffers liest und der Producer neue schreibt, bewegen sich beide ungefähr im gleichen Tempo durch den Ring.

Fällt der Producer einmal zu weit zurück, hat der Consumer nichts zum Abspielen, was hörbare Artefakte wie Klicks oder Knackgeräusche zur Folge hat. Obwohl das Modell theoretisch einfach ist, stellt es strenge Anforderungen an Timing, Speicherallokation und Thread-Verhalten. Diese Anforderungen prägen viele der Designentscheidungen, die später getroffen werden.

Ein wichtiger Punkt dabei ist, dass der Consumer in Echtzeit laufen muss, also keine blockierenden Operationen ausführen darf, etwa Speicherallokation oder I/O. Der Producer hat diese Einschränkung nicht ganz, da er ein paar buffers voraus ist, sollte aber trotzdem performant arbeiten, um nicht zu stark zurückzufallen und dadurch Artefakte einzuführen.
