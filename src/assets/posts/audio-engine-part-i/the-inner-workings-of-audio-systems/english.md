We could definitely get into the nitty gritty of [digital audio](https://www.izotope.com/en/learn/digital-audio-basics-sample-rate-and-bit-depth), but at a high level audio is typically represented as a sequence of floating-point values. Each float is typically between -1.0 and 1.0 and represents the amplitude of the signal at a given point in time. Rather than working with individual samples, audio systems process these values in chunks (buffers). For reference, buffers are typically powers of two in size, often around 256 or 512 samples.

Most real-time audio systems are built around a [producer-consumer model](https://jenkov.com/tutorials/java-concurrency/producer-consumer.html). There is usually a dedicated audio thread that acts as the consumer, being owned by the platform's audio system, and it's responsible for pulling buffers at a very precise interval (often tied closely to the underlying audio hardware). The consumer looks slightly different on each platform in this project, for example an `AudioWorklet` on the web or an `AURenderCallback` on iOS, however they ultimately follow the same kind of logic (more on that later).

On the other side is the producer, which is responsible for generating audio data ahead of time. This typically runs on a separate thread, not the main UI thread, and continuously fills buffers with audio samples so they are ready when the audio thread asks for them.

The producer and consumer are most commonly connected using a [ring buffer](https://en.wikipedia.org/wiki/Circular_buffer). A ring buffer is a contiguous block of memory that is reused in a circular fashion. When the producer reaches the end of the buffer, it wraps back around to the beginning. For audio, this works well by keeping the producer slightly ahead of the consumer, usually by a few buffers. As the consumer reads buffers and the producer writes new ones, both advance through the ring at roughly the same pace.

If the producer ever falls too far behind, the consumer has nothing to play, which results in audible artifacts such as clicks and pops. While the model is simple in theory, it places strict constraints on timing, memory allocation, and thread behavior, and those constraints end up driving many of the design decisions down the road.

One key thing to note at this point is that the consumer needs to run in real-time, meaning no blocking operations (such as memory allocation, I/O, etc.). The producer doesn't quite have this constraint since it's a few buffers ahead, but it should still stick to performant operations so as not to fall too far behind, subsequently introducing artifacts.
